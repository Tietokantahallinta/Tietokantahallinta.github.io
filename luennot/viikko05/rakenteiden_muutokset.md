# Rakenteiden muutokset

Tietokannan rakennetta (eli skeemaa) joudutaan usein muuttamaan tietokannan elinkaaren aikana. N√§m√§ muutokset voivat olla yksinkertaisia tai hyvinkin monimutkaisia, ja joskus SQL Server Management Studion (SSMS) graafinen suunnitteluty√∂kalu ei riit√§, vaan tarvitaan tarkkaan suunniteltuja ja testattuja skriptej√§.

### Yleisi√§ tilanteita, joissa rakennetta muutetaan:
- Uusien liiketoimintavaatimusten t√§ytt√§minen, esimerkiksi sovellukseen lis√§t√§√§n uusia ominaisuuksia, jolloin tarvitaan uusia tauluja, sarakkeita, relaatiota jne.
- Tietomallin optimointi
- Normalisointi tai denormalisointi tietokannan suorituskyvyn tai yll√§pidett√§vyyden parantamiseksi tai k√§yt√∂n helpottamiseksi.
- Suorituskykyongelmien korjaaminen
- Indeksien lis√§√§minen tai muuttaminen.
- Partitiointi.
- Tietotyyppien muuttaminen tehokkaammiksi.
- Virheiden korjaaminen tietomallissa, esimerkiksi v√§√§r√§ tietotyyppi, puuttuva rajoite (foreign key, unique jne.).
- Integraatio muiden j√§rjestelmien kanssa, esim. sovelluksen t√§ytyy l√§hett√§√§ tai vastaanottaa dataa ulkoisista l√§hteist√§, mik√§ vaatii lis√§kentti√§ tai konversiota.

Indeksit ja niiden muokkaaminen j√§tet√§√§n toistaiseksi k√§sittelem√§tt√§, palataan niihin hieman tuonnempana.

SSMS osaa tehd√§ (jos se on optioista sallittu) aika paljon erilaisia muutoksia graafisen k√§ytt√∂liittym√§n kautta, mutta kaikki ei onnistu.
Hankalia tai monimutkaisia tilanteita, joissa graafinen ty√∂kalu ei riit√§:
- Sarakkeen tyypin muuttaminen, kun taulussa on dataa, esim. VARCHAR(10) ‚Üí INT: vaatii datan muuntamista ja validointia ennen muutosta, jos koko data on sis√§lt√§√§ vain kokonaislukuja merkkijonona, onnistuu muutos ilman ongelmia.
- Sarakkeen nimen muuttaminen, kun se on k√§yt√∂ss√§ riippuvuuksissa. Esim. n√§kym√§t, proseduurit, funktiot, triggerit, kaikki n√§m√§ voivat viitata kyseiseen sarakkeeseen. SSMS ei osaa automaattisesti p√§ivitt√§√§ niit√§ kaikkia.
- Taulujen uudelleenrakentaminen, esimerkiksi jos halutaan muuttaa PRIMARY KEY -rakennetta tai yhdist√§√§ useampi taulu yhteen: vaatii usein datan migraatiota ja useiden objektien (indeksit, constraintit, triggerit) uudelleenluontia.
- Tietojen konvertointi skeemamuutoksen yhteydess√§
- Jos sarakkeen tyyppi muuttuu tai sarakkeita yhdistet√§√§n/jaetaan, pit√§√§ kirjoittaa skripti, joka p√§ivitt√§√§ olemassa olevat tiedot.
- Rakennemuutokset tuotantoymp√§rist√∂ss√§
- Tarvitaan tarkkaan suunniteltuja skriptej√§, jotka:
    - Eiv√§t riko objekteja, jotka viittaavat muutettaviin tauluihin ja sarakkeisiin
    - S√§ilytt√§v√§t datan
    - Ovat suoritettavissa "hot" tilassa (ilman k√§ytt√∂katkoa)
    - Indeksien tai constraintien hallinta, esim. UNIQUE constraintin lis√§√§minen tauluun, jossa on duplikaatteja ‚Üí pit√§√§ ensin l√∂yt√§√§ ja k√§sitell√§ duplikaatit.
- Partitioinnin lis√§√§minen olemassa olevaan tauluun
- Refaktorointi, jossa pit√§√§ s√§ilytt√§√§ taaksep√§in yhteensopivuus, esim. uuden sarakkeen k√§ytt√∂√∂notto siten, ett√§ vanhat proseduurit ja n√§kym√§t edelleen toimivat.

## Huomioitava seikka
Tietokannan muutoksissa selvit√§ onnistuuko muutos 'lennossa' eli samaan aikaan kun tietokanta on normaalissa k√§yt√∂ss√§. Tai riitt√§√§k√∂ ett√§ on joku rauhallinen hetki, esimerkiksi illalla klo 20 jolloin k√§ytt√§ji√§ on v√§h√§n. 
Tarvittaessa tietokannan voi asettaa single-user -moodiin. T√§ll√∂in tietokannassa voi tehd√§ rauhassa huoltotoimenpiteit√§, mutta se ei ole silloin normaalissa k√§yt√∂ss√§. Asetus tapahtuu SSMS:n avulla tietokanta-aseuksista (Options), viimeinen valinta (State) Restrict Access ja asetuksena SINGLE_USER. T√§m√§n asetuksen j√§lkeen katkeaa kaikki muut yhteydet (istunnot) v√§litt√∂m√§sti ilman mit√§√§n varoitusta.
TSQL-komennoilla voi tehd√§ tietysti saman:

```sql
USE master;
GO
ALTER DATABASE AdventureWorks2022
    SET SINGLE_USER
    WITH ROLLBACK IMMEDIATE;
GO
-- takaisin normaaliin tilaan:
ALTER DATABASE AdventureWorks2022
    SET MULTI_USER;
GO```

On my√∂s mahdollista k√§ynnist√§√§ tietokantapalvelin rajoitetussa tilassa, esimerkiksi seuraava komento sallii vain SSMS:n Query-ikkunan kautta kytkeytymisen ja siirtyy samalla single-user moodiin (on ensin stop-komennolla pys√§ytett√§v√§):
```cmd
net start "SQL Server (MSSQLSERVER)" /m"Microsoft SQL Server Management Studio - Query"
```

### üõ†Ô∏è Milloin skripti on parempi kuin graafinen ty√∂kalu
- Kun muutoksessa tarvitaan loogisia tarkistuksia (esim. "jos data on t√§t√§ muotoa, tee n√§in").
- Kun halutaan versiohallittavia muutoksia (esim. osana CI/CD-putkea).
- Kun muutoksen vaikutukset ulottuvat moniin objekteihin.
- Kun tietom√§√§r√§ on suuri ja pit√§√§ hallita muutoksen suoritusnopeutta tai lukituksia.
- Kun muutoksia t√§ytyy tehd√§ automaattisesti useaan ymp√§rist√∂√∂n (esim. dev, test, prod).
- Esimerkkin√§ on vaikkapa yksi yleinen ja hankala tilanne ‚Äì eli sarakkeen tietotyypin muuttaminen, kun taulussa on jo dataa ja sarake voi olla k√§yt√∂ss√§ indekseiss√§ tai viittauksissa.

üéØ **Tilanne:**
Taulussa Asiakkaat on sarake PuhelinNumero tyyppi√§ VARCHAR(10), mutta se halutaan muuttaa tyyppiin VARCHAR(20), koska ulkomaiset numerot eiv√§t mahdu nykyiseen kentt√§√§n.

Lis√§haasteet:
- Taulussa on jo tuhansia rivej√§ dataa.
- Sarake on osa UNIQUE-indeksi√§.
- Halutaan tehd√§ muutos turvallisesti tuotantotietokannassa ilman k√§ytt√∂katkoa.

‚úÖ Tavoite:
Muuttaa PuhelinNumero-sarakkeen tietotyyppi menett√§m√§tt√§ dataa, rikkomatta riippuvuuksia, ja pit√§√§ indeksi ennallaan.

üß† Vaiheittainen skripti:
```sql
-- 1. Tarkistetaan nykyinen rakenne ja riippuvuudet
EXEC sp_help 'dbo.Asiakkaat';

-- 2. Luodaan v√§liaikainen sarake uudella tietotyypill√§
ALTER TABLE dbo.Asiakkaat
    ADD PuhelinNumero_tmp VARCHAR(20);

-- 3. Kopioidaan data vanhasta sarakkeesta uuteen
UPDATE dbo.Asiakkaat
    SET PuhelinNumero_tmp = PuhelinNumero;

-- 4. Poistetaan riippuvaisuudet (indeksit, constraintit)
-- Huom: t√§m√§ riippuu rakenteesta ‚Äì t√§ss√§ esimerkkin√§ UNIQUE-indeksin poisto
DROP INDEX IX_Asiakkaat_PuhelinNumero ON dbo.Asiakkaat;

-- 5. Poistetaan vanha sarake
ALTER TABLE dbo.Asiakkaat
DROP COLUMN PuhelinNumero;

-- 6. Uudelleennimet√§√§n uusi sarake vanhaksi
EXEC sp_rename 'dbo.Asiakkaat.PuhelinNumero_tmp', 'PuhelinNumero', 'COLUMN';

-- 7. Luodaan indeksi uudelleen
CREATE UNIQUE NONCLUSTERED INDEX IX_Asiakkaat_PuhelinNumero
ON dbo.Asiakkaat(PuhelinNumero);

-- 8. (Valinnainen) P√§ivit√§ proseduurit/n√§kym√§t jos ne viittasivat vanhaan sarakkeen rakenteeseen
```

üõ°Ô∏è **Huomioitavaa:**
- Jos sarake on foreign key-suhteessa toiseen tauluun, se pit√§√§ ensin poistaa ja lis√§t√§ uudelleen.
- Jos sarake on p√§√§avain tai osa computed columnia, tarvitaan enemm√§n vaiheita.
- Tuotantoymp√§rist√∂ss√§ kannattaa aina tehd√§ backup ja testata skripti staging- tai test-ymp√§rist√∂ss√§ ensin.

Esimerkki viel√§ vaikeammasta tilanteesta, kuten sarakkeen jakamisesta kahdeksi (esim. Nimi ‚Üí Etunimi, Sukunimi):

üéØ **Tilanne:**
Taulussa Henkilot on sarake Nimi (esim. "Matti Meik√§l√§inen") tyyppi√§ VARCHAR(100). Haluamme jakaa t√§m√§n kahdeksi sarakkeeksi:
- Etunimi
- Sukunimi
Lis√§haasteet:
- Taulussa on jo paljon dataa.
- Sarake Nimi on k√§yt√∂ss√§ useissa n√§kymiss√§ ja raporteissa.
- Kaikissa nimiss√§ ei ole t√§sm√§lleen kaksi osaa (esim. "Anna-Maria Virtanen", "Jari").

‚úÖ Tavoite:
Jakaa Nimi-sarake turvallisesti kahtia, s√§ilytt√§√§ alkuper√§inen data ja minimoida h√§iri√∂ vaikutuksille.

üß† Vaiheittainen ratkaisu:
```sql
-- 1. Lis√§t√§√§n uudet sarakkeet
ALTER TABLE Henkilot
ADD Etunimi VARCHAR(20), 
    Sukunimi VARCHAR(30);

-- 2. P√§ivitet√§√§n uudet sarakkeet datalla
-- T√§ss√§ oletetaan, ett√§ etunimi on ensimm√§inen sana, sukunimi loput
UPDATE Henkilot
SET Etunimi = LTRIM(RTRIM(LEFT(Nimi, CHARINDEX(' ', Nimi + ' ') - 1))),
    Sukunimi = LTRIM(RTRIM(SUBSTRING(Nimi, CHARINDEX(' ', Nimi + ' ') + 1, LEN(Nimi))));

-- 3. Tarkistetaan jako (esim. NULL-arvot, virheet)
SELECT Nimi, Etunimi, Sukunimi
FROM Henkilot
WHERE Sukunimi IS NULL OR Etunimi IS NULL;

-- 4. P√§√§tet√§√§n, mit√§ tehd√§√§n alkuper√§iselle sarakkeelle
-- a) jos halutaan pit√§√§ historiaa: j√§tet√§√§n sarake
-- b) jos halutaan poistaa:
-- ALTER TABLE dbo.Henkilot DROP COLUMN Nimi;

-- 5. P√§ivitet√§√§n n√§kym√§t, proseduurit, raportit jne.
-- Etsi kaikki kohdat, joissa k√§ytet√§√§n "Nimi"-saraketta:
-- (T√§m√§ l√∂yt√§√§ riippuvuuksia)
SELECT OBJECT_NAME(object_id), definition 
FROM sys.sql_modules 
WHERE definition LIKE '%Nimi%';

-- 6. (Valinnainen) Luodaan computed column alkuper√§isell√§ rakenteella
-- Jos vanha sarake halutaan emuloida:
ALTER TABLE dbo.Henkilot
    ADD Nimi AS (Etunimi + ' ' + Sukunimi);
```

**Huomioitavaa:**
- T√§m√§ jako toimii vain yksinkertaisissa nimiss√§. Jos haluat k√§sitell√§ moniosaisia nimi√§ (esim. "Jean von Hellens", "Teppo Matti Tuppurainen"), kannattaa k√§ytt√§√§ kehittyneemp√§√§ parsintaa tai jopa erillist√§ ETL-prosessia. ETL (Extract, Transform, Load) prosessissa siirret√§√§n ensin data johonkin toiseen j√§rjestelm√§√§n tai tietokantaan, tehd√§√§n tarvittavat muunnokset/korjaukset ja sitten ladataan p√§ivitetty data takaisin alkuper√§iseen tietokantaan. T√§m√§n voi tehd√§ monella erilaisella tavalla, ja hyvin luultavasti vaatii ohjelmointia.
- Jos Nimi on k√§yt√∂ss√§ indeksoituna sarakkeena, muutos voi vaikuttaa suorituskykyyn.
- Jos j√§rjestelm√§ss√§ on audit-trail tai integraatioita muihin j√§rjestelmiin, niiden yhteensopivuus pit√§√§ varmistaa.


**Esimerkki taulun jakamisesta kahteen:**
üéØ Tilanne: taulussa *Henkilot* on henkil√∂iden perustiedot sek√§ yhteystiedot yhdess√§ taulussa:

```sql
CREATE TABLE Henkilot (
    HenkiloID INT PRIMARY KEY,
    Nimi VARCHAR(100),
    Email VARCHAR(50),
    Puhelin VARCHAR(20),
    Osoite VARCHAR(200)
);
```

Halutaan erottaa yhteystiedot omaksi taulukseen, esim. seuraavista syist√§:
- Yhteystietoja k√§ytet√§√§n eri j√§rjestelm√§ss√§.
- Yhteystiedot voivat muuttua useammin kuin perustiedot.
- Halutaan normalisoida tietokantarakenne.

‚úÖ Tavoite
Jaetaan taulu kahdeksi:
- Henkilot: sis√§lt√§√§ HenkiloID ja Nimi
- Yhteystiedot: sis√§lt√§√§ HenkiloID, Email, Puhelin, Osoite
- Ja pidet√§√§n HenkiloID-viiteavaimena n√§iden v√§lill√§.

üß† Ratkaisu vaiheittain
```sql
-- 1. Luodaan uusi taulu Yhteystiedot
CREATE TABLE Yhteystiedot (
    HenkiloID INT PRIMARY KEY,
    Email VARCHAR(100),
    Puhelin VARCHAR(20),
    Osoite VARCHAR(200),
    CONSTRAINT FK_Yhteystiedot_Henkilot FOREIGN KEY (HenkiloID)
        REFERENCES Henkilot(HenkiloID)
);

-- 2. Siirret√§√§n tiedot uuteen tauluun
INSERT INTO Yhteystiedot (HenkiloID, Email, Puhelin, Osoite)
SELECT HenkiloID, Email, Puhelin, Osoite
FROM Henkilot;

-- 3. Poistetaan yhteystiedot alkuper√§isest√§ taulusta
ALTER TABLE Henkilot
DROP COLUMN Email;

ALTER TABLE Henkilot
DROP COLUMN Puhelin;

ALTER TABLE Henkilot
DROP COLUMN Osoite;
```

üîó Lopputulos:
Nyt Henkilot ja Yhteystiedot ovat kahdessa eri taulussa, mutta yhdistett√§viss√§ yhdell√§ liittym√§ll√§ (JOIN) HenkiloID:n kautta.

Esim. kysely kaikkien tietojen saamiseksi:
```sql
SELECT h.HenkiloID, h.Nimi, y.Email, y.Puhelin, y.Osoite
FROM Henkilot h
JOIN Yhteystiedot y ON h.HenkiloID = y.HenkiloID;
```

üîí Hyvi√§ k√§yt√§nt√∂j√§:
- Lis√§√§ FOREIGN KEY-viite est√§m√§√§n orpoja rivej√§ (kuten yll√§ on tehty).
- Voit k√§ytt√§√§ ON DELETE CASCADE, jos haluat, ett√§ Yhteystiedot poistuvat automaattisesti henkil√∂n poiston yhteydess√§.
- Jos k√§ytet√§√§n sovelluksia, muista p√§ivitt√§√§ kaikki paikat, joissa vanha rakenne oli k√§yt√∂ss√§.

## Synonyymit

[Synonyymit](https://learn.microsoft.com/en-us/sql/relational-databases/synonyms/synonyms-database-engine?view=sql-server-ver16) ovat huonommin tunnettu piirre. Synonyymeist√§ voi kuitenkin olla paljon apua tietokannan muutostenhallinnassa. Synonyymi on alias jollekin SQL-objektille (esim. taulu, n√§kym√§, proseduuri), jonka avulla voit viitata siihen toisella nimell√§.

```sql
CREATE SYNONYM AliasNimi FOR [Tietokanta].[Skeema].[Objekti];
```

‚ú≥Ô∏è Esimerkki: Taulun siirto toiseen skeemaan tai tietokantaan
üß± L√§ht√∂tilanne:
Sinulla on sovellus, joka k√§ytt√§√§ taulua:
```sql
SELECT * FROM dbo.Asiakkaat
```

üõ†Ô∏è Haluat siirt√§√§ taulun toiseen skeemaan:
esim. asiakasdata.Asiakkaat, mutta et voi heti p√§ivitt√§√§ kaikkia sovelluksen SQL-kutsuja.
‚úÖ Ratkaisu: K√§yt√§ synonyymi√§

```sql
--1. Siirr√§ taulu uuteen skeemaan:
ALTER SCHEMA asiakasdata TRANSFER dbo.Asiakkaat;

--2. Luo synonyymi vanhan nimen tilalle:
CREATE SYNONYM dbo.Asiakkaat FOR asiakasdata.Asiakkaat;
```

üß© Nyt vanhat kyselyt, jotka k√§ytt√§v√§t dbo.Asiakkaat, toimivat edelleen, vaikka taulu on siirretty uuteen skeemaan


üîÅ Muita k√§yt√§nn√∂n k√§ytt√∂tapoja
1. V√§liaikainen ohjaus toiseen tauluun
    - Voit kehityksen tai testauksen ajaksi ohjata kyselyt toiseen tauluun ilman, ett√§ muutat sovelluksen koodia.
2. Tietokantojen v√§liset viittaukset
    - Jos k√§yt√§t dataa toisesta tietokannasta:

```sql
CREATE SYNONYM Asiakkaat FOR UlkoinenDB.dbo.Asiakkaat;
```

3. Nimien vakiointi
Sovellus voi k√§ytt√§√§ synonyymej√§ yhten√§isill√§ nimill√§, vaikka fyysiset nimet vaihtelevat ymp√§rist√∂itt√§in (esim. DEV, TEST, PROD).

üß® Varoituksia:
- Synonyymit eiv√§t n√§y helposti graafisissa ty√∂kaluissa (SSMS:n Object Explorerissa voi menn√§ ohi).
- Jos kohdeobjekti muuttuu tai katoaa, synonyymi ei anna virheilmoitusta ennen kuin sit√§ k√§ytet√§√§n.
- Et voi luoda synonyymej√§ temp-tauluihin (#- tai ##-alkuisiin tauluihin).

üß™ Demo: Taulun siirto toiseen tietokantaan synonyymill√§
üîπ L√§ht√∂tilanne
Taulu Asiakkaat on tietokannassa VanhaDB ja haluat siirt√§√§ sen UusiDB-tietokantaan.

Sovelluskoodi k√§ytt√§√§ edelleen:
```sql
SELECT * FROM dbo.Asiakkaat;
```

‚úÖ Vaiheittainen demo
1. Siirr√§ taulu uuteen tietokantaan
```sql

-- Luo uusi tietokanta (jos ei ole)
CREATE DATABASE UusiDB;
GO

-- Oletetaan, ett√§ VanhaDB:ssa on taulu dbo.Asiakkaat
-- Siirret√§√§n tiedot uuteen tietokantaan (manuaalisesti tai skriptill√§)

-- Luo taulu UusiDB:hen
USE UusiDB;
GO
CREATE TABLE dbo.Asiakkaat (
    AsiakasID INT PRIMARY KEY,
    Nimi VARCHAR(100)
);

-- Lis√§√§ testidata
INSERT INTO dbo.Asiakkaat (AsiakasID, Nimi)
VALUES (1, 'Maija Mallikas'), (2, 'Kalle K√§ytt√§j√§');
```
2. Vanha tietokanta: luo synonyymi
```sql
-- Palaa VanhaDB:hen
USE VanhaDB;
GO

-- Poista mahdollinen vanha taulu (jos oli)
DROP TABLE IF EXISTS dbo.Asiakkaat;

-- Luo synonyymi
CREATE SYNONYM dbo.Asiakkaat FOR UusiDB.dbo.Asiakkaat;
3. Testaa kysely
-- T√§m√§ toimii edelleen kuten ennen, mutta data tulee toisesta tietokannasta
SELECT * FROM dbo.Asiakkaat;
```
üîç Sovelluksen tai raportin ei tarvitse tiet√§√§, ett√§ taulu on siirretty toiseen tietokantaan!

Synonyymi on k√§tev√§ keino, kun halutaan pit√§√§ yhteensopivuus rakenteita muutettaessa. Se toimii ik√§√§n kuin v√§lityspisteen√§, jolla voidaan v√§ltt√§√§ koodin rikkominen kesken muutoksen.
Synonyymit ovat loistava tapa:
- Abstrahoida fyysinen rakenne (taulut voivat sijaita miss√§ tahansa).
- Mahdollistaa taulurakenteiden muutokset ilman heti rikkomatta sovelluksia.
- Helpottaa siirtymi√§, integraatioita ja ymp√§rist√∂nvaihtoja.


## Partitiointi

[Partitionti](https://learn.microsoft.com/en-us/sql/relational-databases/partitions/partitioned-tables-and-indexes?view=sql-server-ver16) tarkoittaa sit√§, ett√§ suuri taulu jaetaan loogisesti pienempiin osiin eli partitioihin, vaikka se n√§ytt√§√§ edelleen yhdelt√§ taululta k√§ytt√§j√§lle.

‚úÖ Miksi partitioida taulu?
- Parantaa suorituskyky√§, kyselyt voivat kohdistua vain yhteen tai muutamaan partioon, jolloin luetaan v√§hemm√§n dataa.
- Helpottaa yll√§pitoa, vanhimpien tietojen poistaminen tai arkistointi onnistuu helposti partitioiden vaihdolla (partition switch).
- Mahdollistaa tehokkaammat indeksit, indeksit voivat olla partitiokohtaisia.
- Parempi hallinta isoille tietom√§√§rille, esim. miljoonia rivej√§ sis√§lt√§v√§ taulu on paljon helpompi hallita, kun se on loogisesti jaettu.

üîß Miten se toimii teknisesti?
üîπ 1. Partition Function
M√§√§ritt√§√§, miten arvojen perusteella data jaetaan partitioihin. Esim.:

```sql
CREATE PARTITION FUNCTION pf_Vuosi(int)
    AS RANGE LEFT FOR VALUES (2022, 2023);
```

T√§m√§ luo 3 partiota:
- Partitio 1: kaikki ‚â§ 2022
- Partitio 2: kaikki = 2023
- Partitio 3: kaikki > 2023

üîπ 2. Partition Scheme
M√§√§ritt√§√§, mihin fyysisiin tiedostoryhmiin partitiot sijoitetaan (tai kaikki samaan, jos ei tarvita erillist√§ levyjakoa).
```sql
CREATE PARTITION SCHEME ps_Vuosi
    AS PARTITION pf_Vuosi
    ALL TO ([PRIMARY]);
```

üîπ 3. Taulun luominen k√§ytt√§en partition schemaa
```sql
CREATE TABLE MyData (
    Vuosi INT,
    Arvo VARCHAR(100)
)
ON ps_Vuosi(Vuosi);  -- Taulu jaetaan Vuosi-sarakkeen mukaan
```

üìâ Esimerkki k√§yt√∂st√§:
Jos sinulla on lokitaulu Tapahtumat, jossa on miljoonia rivej√§, voit jakaa sen partitoimalla sarakkeen *TapahtumaPvm* mukaan kuukausittain.
T√§ll√∂in kysely:
```sql
SELECT * 
FROM Tapahtumat
WHERE TapahtumaPvm >= '2025-04-01' AND TapahtumaPvm < '2025-05-01'
```
lukee vain yhden partition, ei koko taulua ‚Üí on siis nopeampi verrattuna partitioimattomaan tauluun.

**Milloin kannattaa harkita partitiointia?**
- Taulun rivim√§√§r√§ on huomattava
- Kyselyt kohdistuvat usein aikav√§leihin (esim. yksi kuukausi)
- Tarve poistaa vanhoja tietoja s√§√§nn√∂llisesti
- Halutaan v√§hent√§√§ tietokannan huoltoaikaa (esim. arkistoinnissa)

Partitioinnin lis√§√§minen olemassa olevaan tauluun ei onnistu, joten pit√§√§ tehd√§ seuraavasti:
- Luo partition function ja partition scheme
- Luo uusi partitioitu taulu, jossa sama rakenne
- Siirr√§ data vanhasta taulusta uuteen (INSERT INTO ‚Ä¶ SELECT ‚Ä¶)
- Poista vanha taulu ja nime√§ uusi alkuper√§isen nimiseksi tai k√§yt√§ synonyymi√§

